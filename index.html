<html>
<head>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <style type="text/css">
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        .main {
            display: grid;
            min-height: 100vh;
            grid-template-columns: 1fr;
            grid-template-rows: min-content 1fr min-content;
        }

        .header {
            grid-row: 1;
            grid-column: 1;
        }

        .content {
            position: relative;
            grid-row: 2;
            grid-column: 1;
        }

        .footer {
            grid-row: 3;
            grid-column: 1;
        }

        .axisCanvas {
            height: 30px;
            width: 100%;
        }

        .minimapCanvas {
            height: 15px;
            width: 100%;
        }

        .canvas {
            height: 100%;
            width: 100%;
        }

        .details {
            display: none;
            grid-template-rows: 1fr;
            grid-template-columns: min-content 1fr;
            background-color: darkgray;
            position: absolute;
            margin: 10px;
            padding: 10px;
            bottom: 0;
        }

        .details-focus {
            grid-row: 1;
            grid-column: 1;
            background:
                    url(data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAADUAAAA3CAYAAACsLgJ7AAAAAXNSR0IArs4c6QAAA+dJREFUaAXtmj9vE0EQxQlCILlFQiJSClq3qZHdJIWREG2gJ18ApHRJiUJNg2j5ACAqKByJgooqnSWqCGigoUCAiOD9rFw8Hnn3fHe7tmP5SZOb2d15M/vn9vbOWbuUH12FQAocSUGy4Uo25hFxV+r+yBxqR85Oal5OyrYgZKtOLchElKaxmqnSIVqQBmsZ8miJc1uyJdmQbErWJQW+SPkoOZG8k7yV/JQsHFjGO5JXEhL8V0Fojx/+C3M79JTMsaRKR0Jt4YFvbrilyH1JKMEm5fDCP1N0FO2bJJT4QHVPJXcl3FM3JVfPrtiUU0+7EAf8xJkJdhXlj8Qn81dlLyRtSRXQHj/8PSdxiJcVBPCBsd9IqnbGJ4o/PJP4s3Wsq4B+hk5V9liSEvDBaztH3E7KIHBx0/p76IfKelRmALzw244RP+nm0XcBGMlcHRL1EPD7GSOPJIDcjhj6oyTM5SQsRR+78WDyhPcPVm7mabChRnuS9xKORr/PrtiUUz8N/OZBPo1OHvdFYEeKbbddksk11R9Kfkmsr9eppx3tYyCe3+45UtUGZzKbDM+TGG6o8oPE+pTptMcvBuJaHvKqhZa8/OGUUQuBEa/aoSJR/PAPgbhFW67kRX6VcU8elmhQwnDo2lvfaXT8YyC+5SG/yngmD0vCWS0Ebvqye8hyTdLxj20exLd+5DcRsV3EB2DXCuGBKmLLJ+Rny/GHJwQf3+d37sd3v/1za1zhNG3x2RpOv+PsuiY8TwLOPj75hXIfm1I7vV7n9SEEnkO+fR0bnhCIPxXn2lnDEJEtZ3lwsJwEHqy8LzUF/KFlDD9xShG7p7zzdV9g7O9Gb6LGeGLxx2JyTx2MlYyMh1LXR+ZQ/2psq36SEVuetm1MhycEmwttWKrPQ41D5a9VYdcwr+Ah7KnCtq2rwxMC8S0v+U1EbPmdOI/bzrbmSxlTrXfr5HT84QnBx/f5hfzGypfyRMHZaunOfkzb0p3S6dSOxN6cS/E+xUZy7Dp24d981Z/hBxY7W+h8O5gFsnyjKBLvS7EdO5XdKyozXeEnjo1LHsmwlN/9GJ2OhAOnHTlGMvXnMvj8DBGX+FmwK1bbqUJn82g3jIg/PAWnvRI3KwjgZ4wE2O756lO1c7THD3/bEXTiZO+QYgzR1V//bd0mNFA93xSa/j5FnJmCzaMvsZ1JpcOb9MeAqiPTk4N/QNftHDzwLQQ4eXCk4qzoD8FlHaQ9fvjHXoVUPR34RpEaLRFuS7YkG5JNybqkAG+sF+L/KIqEJ10PVGhnCzsrkkx31gxrkK86VWPQ5uKymqm5DHuNoLP4x+Ajl5e3XXVz8z/hZnJasj74OAAAAABJRU5ErkJggg==)
                    no-repeat
                    left center;
            cursor: pointer;
            width: 20px;
            height: 20px;
            background-size: cover;
        }

        .details-focus:hover {
            opacity: .5;
        }

        .details-name {
            grid-row: 1;
            grid-column: 2;
            font-family: 'Roboto', sans-serif;
            font-size: 10px;
            padding-left: 10px;
            align-self: center;
        }

        .progress {
            height: 5px;
            width: 100%;
            transform: scale(0, 1);
            transform-origin: left;
            /* Transitions are janky for some reason */
            /*transition: 100ms linear;*/
            /*transition-property: transform;*/
            background-color: green;
        }

        .searchResultRow {
            font-family: 'Roboto', sans-serif;
            font-size: 12px;
            padding-left: 10px;
            padding-top: 5px;
            padding-bottom: 5px;
            cursor: pointer;
        }

        .searchResultRow:hover {
            background-color: darkgray;
        }
    </style>
</head>
<body>
<div class="main">
    <div class="header">
        <div id="progress" class="progress"></div>
        <input type="file" id="file" name="file">
        <input type="text" id="search" name="search">
        <div id="searchResults" class="searchResults"></div>
        <canvas class="axisCanvas" id="axisCanvas"></canvas>
    </div>
    <div class="content">
        <canvas class="canvas" id="canvas"></canvas>
        <div class="details" id="details">
            <div class="details-focus"></div>
            <div class="details-name"></div>
        </div>
    </div>
    <div class="footer">
        <canvas class="minimapCanvas" id="minimapCanvas"></canvas>
    </div>
</div>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix-min.js"></script>

<script>
    'use strict';

    const PIXEL_RATIO = (function () {
        let context = canvas.getContext("2d"),
            dpr = window.devicePixelRatio || 1,
            bsr = context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;

        return dpr / bsr;
    })();

    const THEME = {
        'AXIS_LINE_COLOR': '#FFFFFF',
        'AXIS_LINE_STROKE_WIDTH': PIXEL_RATIO * 2,
        'AXIS_BACKGROUND_COLOR': '#303030',
        'AXIS_HEIGHT': PIXEL_RATIO * 30,
        'VIEW_PORT_COLOR': "#081016",
        'EVENT_BORDER_COLOR': '#2a555f',
        'EVENT_HEIGHT': 40,
        'COLOR_PALETTE':
            [
                '#4f68ab',
                '#4b66a6',
                '#415a94',
                '#374d80',
                '#30446f',
                '#28375e',
                '#202e4f',
                '#4d7166',
                '#83b8ab',
                '#151918',
                '#1b2b26'
            ],
        "MARGIN_AROUND_METHODS_AT_START": 0.10,
    };

    // Processes raw trace data bytes. Consume processed data by registering callbacks:
    //     onProgress(bytesRead), onDone(methodRegistry), onPush(call), onPop(call)
    class TraceDataProcessor {

        constructor(bytes) {
            this.charZero = '0'.charCodeAt(0);
            this.charColon = ':'.charCodeAt(0);
            this.charNewline = '\n'.charCodeAt(0);
            this.charPeriod = '.'.charCodeAt(0);
            this.charLeftParen = '('.charCodeAt(0);

            this.onProgress = () => {
            };
            this.onDone = () => {
            };
            this.onPush = () => {
            };
            this.onPop = () => {
            };
            this.methodRegistry = new MethodRegistry();
            this.callStack = [];
            this.firstTimestamp = -1;
            this.timestamp = -1;
            this.done = false;
            this.totalBytes = bytes.length;
            this.bytesRead = 0;

            let it = bytes.values();
            this.next = () => {
                this.bytesRead++;
                return it.next();
            };
        }

        load() {
            this.loop();
        }

        loop() {
            this.loadWithDeadline(this.createDeadline());
            if (this.done) {
                this.onProgress(this.totalBytes);
                this.onDone(this.methodRegistry);
            } else {
                this.onProgress(this.bytesRead);
                requestAnimationFrame(this.loop.bind(this));
            }
        }

        createDeadline() {
            let timeout = 500;
            let deadline = Date.now() + timeout;
            return {
                timeRemaining: () => deadline - Date.now()
            };
        };

        loadWithDeadline(deadline = {timeRemaining: () => 1}) {
            while (!this.done && deadline.timeRemaining() > 0) {
                this.loadLine();
            }
            if (this.done) {
                while (this.callStack.length > 0) {
                    this.pop();
                }
            }
        }

        loadLine() {
            let loadedTimestamp = this.loadTimestamp();
            if (this.done) {
                return;
            }
            this.timestamp = loadedTimestamp;
            let names = this.loadName();
            let name = names[0];
            let shortName = names[1];
            if (this.firstTimestamp === -1) {
                this.firstTimestamp = this.timestamp;
            }
            this.timestamp -= this.firstTimestamp;
            if (name === "POP") {
                if (this.callStack.length > 0) {
                    this.pop();
                }
            } else {
                let stackDepth = this.callStack.length + 1;
                let call = new TraceCall(name, shortName, stackDepth, this.timestamp);
                this.callStack.push(call);
                this.onPush(call);
            }
        }

        pop() {
            let call = this.callStack.pop();
            call.end = this.timestamp;
            this.methodRegistry.addCall(call);
            this.onPop(call);
        }

        loadTimestamp() {
            let next = this.next();
            if (next.done) {
                this.done = true;
                return;
            }

            let timestamp = 0;
            while (next.value !== this.charColon) {
                timestamp *= 10;
                timestamp += next.value - this.charZero;
                next = this.next();
            }
            return timestamp;
        }

        loadName() {
            let name = "";
            let shortName = "";
            let next = this.next();
            let index = 0;
            let periods = [];
            while (!next.done && next.value !== this.charNewline) {
                if (!shortName) {
                    if (next.value === this.charPeriod) {
                        if (periods.size < 2) {
                            periods.push(index);
                        } else {
                            periods[0] = periods[1];
                            periods[1] = index;
                        }
                    } else if (next.value === this.charLeftParen) {
                        shortName = name.substring(periods[0] + 1, index)
                    }
                }
                name += String.fromCharCode(next.value);
                next = this.next();
                index++;
            }
            return [name, shortName];
        }
    }

    // Caches rasterized text.
    class TextPool {

        constructor() {
            this.canvases = {};
            this.font = '18px Roboto';
        }

        getOrRasterize(name) {
            let canvas = this.canvases[name];
            if (canvas) {
                return canvas;
            }

            canvas = this._rasterize(name);
            this.canvases[name] = canvas;
            return canvas;
        }

        _rasterize(name) {
            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');

            context.fillStyle = "white";
            context.font = this.font;
            context.textBaseline = 'middle';
            let textSize = context.measureText(name);
            let textWidth = textSize.width;
            let textHeight = THEME.EVENT_HEIGHT;
            canvas.width = textWidth * PIXEL_RATIO;
            canvas.height = textHeight;

            context.fillStyle = "white";
            context.font = this.font;
            context.textBaseline = 'middle';
            context.fillText(name, 0, canvas.height / 2);
            return canvas;
        }
    }

    // Represents a single invocation of a method.
    class TraceCall {

        constructor(name, shortName, stackDepth, start) {
            this.name = name;
            this.shortName = shortName;
            this.stackDepth = stackDepth;
            this.start = start;
        }
    }

    // Represents a method. Multiple TraceCalls can be associated with a single TraceMethod.
    class TraceMethod {

        constructor(callPrototype) {
            this.name = callPrototype.name;
            this.shortName = callPrototype.shortName;
            this.calls = [];
        }

        getCallAt(index) {
            return this.calls[index];
        }

        addCall(call) {
            this.calls.push(call);
        }
    }

    // Holds all TraceMethod information for a trace file.
    class MethodRegistry {

        constructor() {
            this.methods = {};
            this.data = "\"";
            this.minTimestamp = 0;
            this.maxTimestamp = 0;
            this.maxStackDepth = 1;
        }

        addCall(call) {
            let method = this.methods[call.name];
            if (!method) {
                method = new TraceMethod(call);
                this.methods[call.name] = method;
                this.data += call.name;
                this.data += "\"";
            }
            method.addCall(call);

            this.minTimestamp = Math.min(this.minTimestamp, call.start);
            this.maxTimestamp = Math.max(this.maxTimestamp, call.end);
            this.maxStackDepth = Math.max(this.maxStackDepth, call.stackDepth);
        }

        search(query, limit = 10) {
            if (query.length === 0) {
                return [];
            }
            let rx = new RegExp('"([^"]*' + query + '[^"]*)"', 'gi');
            let i = 0, results = [], result;
            while (result = rx.exec(this.data)) {
                if (i++ > limit) {
                    break;
                }
                let name = result[1];
                results.push(this.methods[name]);
            }

            return results;
        }

        getMethod(name) {
            return this.methods[name];
        }
    }

    class Rect {

        constructor(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
        }
    }

    // Abstraction over underlying transformation matrix.
    class Transform {

        constructor() {
            this.matrix = mat3.create();
            this.screenViewport = new Rect(0, 0, 0, 0);

            this.inverse = mat3.create();
            this.viewport = new Rect(0, 0, 0, 0);
        }

        applyTo(context) {
            context.setTransform(this.matrix[0], this.matrix[1], this.matrix[3], this.matrix[4], this.matrix[6], this.matrix[7]);
        }

        setScreenViewport(screenViewport) {
            this.screenViewport = screenViewport;
            this._refresh();
        }

        getViewport() {
            return this.viewport;
        }

        getScreenViewport() {
            return this.screenViewport;
        }

        getScaleX() {
            return this.matrix[0];
        }

        getScaleY() {
            return this.matrix[4];
        }

        getTranslationX() {
            return this.matrix[6];
        }

        getTranslationY() {
            return this.matrix[7];
        }

        toScreenPosition(modelPosition) {
            return vec2.transformMat3(vec2.create(), modelPosition, this.matrix);
        }

        toModelPosition(screenPosition) {
            return vec2.transformMat3(vec2.create(), screenPosition, this.inverse);
        }

        focus(left, top, width) {
            let scale = this.screenViewport.width / width;
            mat3.fromScaling(this.matrix, vec2.fromValues(scale, 1));
            mat3.translate(this.matrix, this.matrix, vec2.fromValues(-left, -top));
            this._refresh();
        }

        _scroll(dx, dy) {
            let translation = vec2.fromValues(dx / this.getScaleX(), dy);
            mat3.translate(this.matrix, this.matrix, translation);
            // Enforce top bounds: no reason we should allow the user to scroll well beyond the top of the screen.
            this.matrix[7] = Math.min(this.screenViewport.top / this.matrix[4], this.matrix[7]);
            this._refresh();
        }

        _scale(scale, x, y) {
            let K = 10;
            let originalScreenPoint = vec2.fromValues(x, y);
            let originalModelPoint = this.toModelPosition(originalScreenPoint);
            scale = Math.sign(scale) * Math.min(K, Math.abs(scale)) / K + 1;
            mat3.scale(this.matrix, this.matrix, vec2.fromValues(scale, 1));
            let newScreenPoint = this.toScreenPosition(originalModelPoint);
            let offsetX = originalScreenPoint[0] - newScreenPoint[0];
            let offsetY = originalScreenPoint[1] - newScreenPoint[1];
            mat3.translate(this.matrix, this.matrix, vec2.fromValues(offsetX / this.matrix[0], offsetY));
            this._refresh();
        }

        onMouseWheel(event) {
            if (event.ctrlKey) {
                let boundingRect = canvas.getBoundingClientRect();
                let x = event.clientX - boundingRect.left;
                let y = event.clientY - boundingRect.top;
                x *= PIXEL_RATIO;
                y *= PIXEL_RATIO;
                this._scale(-event.deltaY / 10, x, y);
            } else {
                this._scroll(-event.deltaX, -event.deltaY);
            }
        }

        onKeyPress(keyCode) {
            let SCROLL_JUMP = 200;
            let SCALE_JUMP = 4;
            if (keyCode === 65) { // a
                this._scroll(SCROLL_JUMP, 0);
            } else if (keyCode === 68) { // d
                this._scroll(-SCROLL_JUMP, 0);
            } else if (keyCode === 87) { // w
                let boundingRect = canvas.getBoundingClientRect();
                this._scale(SCALE_JUMP, (boundingRect.left + boundingRect.right) / 2 * PIXEL_RATIO,
                    boundingRect.top + boundingRect.height / 2 * PIXEL_RATIO);
            } else if (keyCode === 83) { // s
                let boundingRect = canvas.getBoundingClientRect();
                this._scale(-SCALE_JUMP, (boundingRect.left + boundingRect.right) / 2 * PIXEL_RATIO,
                    boundingRect.top + boundingRect.height / 2 * PIXEL_RATIO);
            } else {
                return false;
            }
            return true;
        }

        _refresh() {
            let screenLeftTop = vec2.fromValues(this.screenViewport.left, this.screenViewport.top);
            let screenRightBottom = vec2.fromValues(screenLeftTop[0] + this.screenViewport.width, screenLeftTop[1] + this.screenViewport.height);

            let inverse = mat3.invert(mat3.create(), this.matrix);
            let viewportLeftTop = vec2.transformMat3(vec2.create(), screenLeftTop, inverse);
            let viewportRightBottom = vec2.transformMat3(vec2.create(), screenRightBottom, inverse);

            let left = viewportLeftTop[0];
            let top = viewportLeftTop[1];
            let width = viewportRightBottom[0] - left;
            let height = viewportRightBottom[1] - top;

            this.viewport = new Rect(left, top, width, height);
            mat3.invert(this.inverse, this.matrix);
        }
    }

    // Handles displaying trace loading progress.
    class LoadingController {

        constructor() {
            this.progressEl = document.getElementById('progress');
        }

        onStart(totalBytes) {
            this.totalBytes = totalBytes;
            this.progressEl.style.transform = `scale(0, 1)`;
        }

        onProgress(bytesRead) {
            let scale = bytesRead / this.totalBytes;
            this.progressEl.style.transform = `scale(${scale}, 1)`;
        }

        onDone() {
            this.progressEl.style.transform = `scale(0, 1)`;
        }
    }

    // Handles displaying details of selected TraceCall.
    class DetailsController {

        constructor() {
            this.el = document.getElementById('details');
            this.nameEl = this.el.querySelector('.details-name');
            this.focusEl = this.el.querySelector('.details-focus');
            this.focusEl.addEventListener('click', () =>{
                if (this.selectedCall) {
                    this.onFocus(this.selectedCall);
                }
            });
            this.onFocus = () => {};
            this.selectedCall = null;
        }

        selectCall(call) {
            this.selectedCall = call;
            this.nameEl.innerText = call.name;
            this.el.style.display = 'grid';
        }
    }

    // Represents a single row on the canvas.
    class CanvasRowData {

        constructor() {
            this.calls = [];
        }

        addCall(call) {
            this.calls.push(call);
        }

        visitCalls(viewport, run) {
            let leftIndex = this._getLeftIndex(viewport);
            let rightIndex = this._getRightIndex(viewport);
            for (let i = leftIndex; i <= rightIndex; i++) {
                run(this.calls[i]);
            }
        }

        _getLeftIndex(viewport) {
            let leftIndex = CanvasRowData._binarySearch(this.calls, call => call.start, item => item >= viewport.left);
            leftIndex = Math.max(leftIndex - 1, 0);
            return leftIndex;
        }

        _getRightIndex(viewport) {
            let rightIndex = CanvasRowData._binarySearch(this.calls, call => call.end, item => item >= viewport.left + viewport.width);
            rightIndex = Math.min(rightIndex, this.calls.length - 1);
            return rightIndex;
        }

        static _binarySearch(array, map, pred) {
            let lo = -1, hi = array.length;
            while (1 + lo !== hi) {
                const mi = lo + ((hi - lo) >> 1);
                if (pred(map(array[mi]))) {
                    hi = mi;
                } else {
                    lo = mi;
                }
            }
            return hi;
        }
    }

    // Represents the trace data for a given canvas zoom level.
    class CanvasZoomData {

        constructor() {
            this.rows = [];
        }

        addCall(call) {
            while (this.rows.length < call.stackDepth) {
                this.rows.push(new CanvasRowData());
            }
            this.rows[call.stackDepth - 1].addCall(call);
        }

        visitCalls(viewport, run) {
            let stackDepth = 1;
            for (let row of this.rows) {
                let rowTop = CanvasTraceData.getRowTop(stackDepth++);
                let rowBottom = rowTop + CanvasTraceData.getRowHeight();
                if (rowTop < viewport.top + viewport.height && rowBottom > viewport.top) {
                    row.visitCalls(viewport, run);
                }
            }
        }
    }

    // Represents the trace data for all zoom levels.
    class CanvasTraceData {

        constructor() {
            this.clear();
        }

        addCall(call) {
            for (let zoomData of this.zoomDatas) {
                if (call.end - call.start >= zoomData.minCallDuration) {
                    zoomData.addCall(call);
                }
            }
        }

        clear() {
            this.zoomDatas = [];
            this.zoomCount = 10;

            let viewportWidth = 1000;
            let maxCallsPerRow = 10000;
            let zoomFactor = 10;

            for (let i = 0; i < this.zoomCount; i++) {
                let zoomData = new CanvasZoomData();
                zoomData.minCallDuration = viewportWidth / maxCallsPerRow;
                zoomData.viewportWidth = viewportWidth;
                this.zoomDatas.push(zoomData);

                viewportWidth *= zoomFactor;
            }
        }

        // Call run(call) for every on-screen TraceCall at the current zoom level.
        visitCalls(viewport, run) {
            this._getZoomData(viewport).visitCalls(viewport, run);
        }

        _getZoomData(viewport) {
            for (let zoomData of this.zoomDatas) {
                if (viewport.width < zoomData.viewportWidth) {
                    return zoomData;
                }
            }
            return this.zoomDatas[this.zoomDatas.length - 1];
        }

        static getRowTop(stackDepth) {
            return (stackDepth - 1) * CanvasTraceData.getRowHeight();
        }

        static getRowHeight() {
            return THEME.EVENT_HEIGHT;
        }
    }

    // Renders trace data to a canvas.
    class CanvasTraceRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext('2d');
            this.data = new CanvasTraceData();
            this.textPool = new TextPool();
        }

        clear() {
            this.data.clear();
        }

        addCall(call) {
            this.data.addCall(call);
        }

        render() {
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.fillStyle = "black";
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.transform.applyTo(this.context);

            let viewport = this.transform.getViewport();
            this.data.visitCalls(viewport, call => {
                this._renderCall(viewport, call);
            });
            // this._debugViewport();
        }

        focusOnRegistry(methodRegistry) {
            let duration = methodRegistry.maxTimestamp - methodRegistry.minTimestamp;
            this._focusWithMargin(methodRegistry.minTimestamp, 0, duration, THEME.MARGIN_AROUND_METHODS_AT_START);
        }

        focus(call) {
            let left = call.start;
            let top = CanvasTraceData.getRowTop(call.stackDepth);
            let width = call.end - call.start;
            this.transform.focus(left, top, width);
        }

        // Focus on a particular region. With some margin on both sides.
        _focusWithMargin(left, top, width, marginPercent) {
            this.transform.focus(left - width * marginPercent, 0, width * (1 + 2 * marginPercent));
        }

        _debugViewport() {
            let viewport = this.transform.getViewport();
            this.context.strokeStyle = "red";
            this.context.strokeRect(viewport.left, viewport.top, viewport.width, viewport.height);
        }

        _renderCall(viewport, call) {
            let left = call.start;
            let height = CanvasTraceData.getRowHeight();
            let top = CanvasTraceData.getRowTop(call.stackDepth);
            let width = call.end - call.start;

            CanvasTraceRenderer._ensureBackgroundColor(call);
            this.context.fillStyle = call.backgroundColor;
            this.context.fillRect(left, top, width, height);

            let scale = this.transform.getScaleX();
            let cellScreenWidth = scale * width;
            if (cellScreenWidth < 25) {
                return;
            }

            if (call.textCanvas == null) {
                call.textCanvas = this.textPool.getOrRasterize(call.shortName);
            }

            let nameModelHeight = call.textCanvas.height;
            let nameModelWidth = Math.min(width, call.textCanvas.width / PIXEL_RATIO / scale);

            // Preferred name position - centered on screen with slight offset.
            let nameModelLeft = viewport.left + viewport.width / 2 - 300;

            // Ensure name within left bounds.
            nameModelLeft = Math.max(left, nameModelLeft);
            let nameModelRight = nameModelLeft + nameModelWidth;

            // Ensure name within right bounds.
            nameModelRight = Math.min(left + width, nameModelRight);
            nameModelLeft = nameModelRight - nameModelWidth;

            // let nameModelLeft = this.left;
            // noinspection UnnecessaryLocalVariableJS
            let nameModelTop = top;

            let nameModelPosition = vec2.fromValues(nameModelLeft, nameModelTop);
            let nameScreenPosition = this.transform.toScreenPosition(nameModelPosition);
            let nameScreenWidth = nameModelWidth * scale;

            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.drawImage(
                call.textCanvas,
                0, 0, nameScreenWidth, nameModelHeight,
                nameScreenPosition[0], nameScreenPosition[1], nameScreenWidth, nameModelHeight);
            this.context.restore();
        }

        static _ensureBackgroundColor(call) {
            if (call.backgroundColor) {
                return;
            }

            call.backgroundColor = CanvasTraceRenderer._getBackgroundColor(call);
        }

        static _getBackgroundColor(call) {
            let hash = CanvasTraceRenderer._hash(call.shortName);
            let h = hash % THEME.COLOR_PALETTE.length;
            return THEME.COLOR_PALETTE[h];
        }

        static _hash(str) {
            let hash = 5381;
            let i = str.length;
            while (i) {
                hash = (hash * 33) ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
    }

    // Renders the trace minimap.
    class MinimapRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext('2d');
            this.bounds = new Rect(0, 0, 1, 1);
            this.methodRegistry = new MethodRegistry();
            this.rowHeight = 10;
        }

        render() {
            this.context.fillStyle = "grey";
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

            let viewportBox = this.getViewportBox();
            this.context.fillStyle = "darkgrey";
            this.context.fillRect(viewportBox.left, 0, viewportBox.width, canvas.height);
        }

        setMethodRegistry(methodRegistry) {
            this.methodRegistry = methodRegistry;
        }

        getViewportBox() {
            let viewport = this.transform.getViewport();

            let scaleX = canvas.width / (this.methodRegistry.maxTimestamp - this.methodRegistry.minTimestamp);
            let scaleY = this.rowHeight / CanvasTraceData.getRowHeight();
            let matrix = mat3.fromScaling(mat3.create(), vec2.fromValues(scaleX, scaleY));

            let leftTop = vec2.fromValues(viewport.left, viewport.top);
            let rightBottom = vec2.fromValues(viewport.left + viewport.width, viewport.top + viewport.height);

            let screenLeftTop = vec2.transformMat3(vec2.create(), leftTop, matrix);
            let screenRightBottom = vec2.transformMat3(vec2.create(), rightBottom, matrix);

            let screenLeft = screenLeftTop[0];
            let screenTop = screenLeftTop[1];
            let screenWidth = screenRightBottom[0] - screenLeft;
            let screenHeight = screenRightBottom[1] - screenTop;

            return new Rect(screenLeft, screenTop, screenWidth, screenHeight);
        }
    }

    class AxisRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext("2d");
        }

        render() {
            this.transform.applyTo(this.context);
            // Undo the y translation. We always want the y position to be fixed in screen space. This keeps the axis at the top of the screen.
            this.context.translate(0, -this.transform.getTranslationY() / this.transform.getScaleY());

            this.renderAxisBackground();
            this.renderTickMarks();
        }

        renderTickMarks() {
            let viewport = this.transform.getViewport();

            // Goal of the below calculation: we want to have between 5 to 10 different markers on the screen a time.
            // Allowing each division to decrease in size by a factor of 2 before resizing the division achieves about this.
            // Future enhancements: we'll want to modify the math bere by some constants that will cause the numbers to look a
            // bit nicer. For example, we'll want 250ms to be one of the divisions.
            let divisionFactor = Math.log(viewport.width / 5) / Math.log(2);
            divisionFactor = Math.round(divisionFactor);
            let divisionSize = Math.pow(2, divisionFactor);

            let leftViewPortModelCoordinate = viewport.left;
            let firstMajorDivisionOnScreen = Math.floor(leftViewPortModelCoordinate / divisionSize);
            this.context.lineWidth = THEME.AXIS_LINE_STROKE_WIDTH / this.transform.getScaleX();
            for (let majorDivision = firstMajorDivisionOnScreen; majorDivision < firstMajorDivisionOnScreen + 10; majorDivision++) {
                // note we can't allow the multiplication to affect this.
                this.context.beginPath();
                this.context.moveTo(majorDivision * divisionSize, 0);
                this.context.lineTo(majorDivision * divisionSize, THEME.AXIS_HEIGHT);
                this.context.stroke();
                this.context.closePath();

                for (let minorDivision = 0; minorDivision < 5; minorDivision++) {
                    this.context.beginPath();
                    this.context.moveTo(majorDivision * divisionSize + minorDivision * divisionSize / 5, 0);
                    this.context.lineTo(majorDivision * divisionSize + minorDivision * divisionSize / 5, 1 / 3 * THEME.AXIS_HEIGHT);
                    this.context.stroke();
                    this.context.closePath();
                }

                this.context.fillStyle = THEME.AXIS_LINE_COLOR;
                this.context.save();
                this.context.textBaseline = 'middle';
                this.context.translate(majorDivision * divisionSize, THEME.AXIS_HEIGHT / 2);
                this.context.scale(1 / this.transform.getScaleX(), 1);
                this.context.font = '24px Roboto';
                this.context.fillText("  " + AxisRenderer.formatTime(majorDivision * divisionSize, divisionSize), 0, 0);
                this.context.restore();
            }

            this.context.closePath();
        }

        renderAxisBackground() {
            let viewport = this.transform.getViewport();

            this.context.fillStyle = THEME.AXIS_BACKGROUND_COLOR;
            this.context.fillRect(viewport.left, 0, viewport.width, THEME.AXIS_HEIGHT);
            this.context.strokeStyle = THEME.AXIS_LINE_COLOR;
            this.context.lineWidth = THEME.AXIS_LINE_STROKE_WIDTH;

            // Draw axis from -inf to +inf. For some reason drawing from left to right doesn't work with large numbers.
            this.context.save();
            this.context.resetTransform();

            let screenViewport = this.transform.getScreenViewport();
            this.context.beginPath();
            this.context.moveTo(screenViewport.left, THEME.AXIS_HEIGHT);
            this.context.lineTo(screenViewport.left + screenViewport.width, THEME.AXIS_HEIGHT);
            this.context.stroke();
            this.context.restore();
        }

        static formatTime(time, divisionSize) {
            // TODO: this needs to be improved. For now we just show everything in ns.
            return Math.round(time) + " ns"
        }
    }

    // Handles search.
    class SearchController {

        constructor() {
            this.methodRegistry = new MethodRegistry();
            this.resultsEl = document.getElementById('searchResults');
            this.onSelected = () => {
            };
        }

        onQuery(query) {
            this.clearResults();
            let methods = this.methodRegistry.search(query, 10);
            for (let method of methods) {
                this.resultsEl.appendChild(this.createResultEl(method));
            }
        }

        setMethodRegistry(methodRegistry) {
            this.methodRegistry = methodRegistry;
        }

        clearResults() {
            while (this.resultsEl.firstChild) {
                this.resultsEl.removeChild(this.resultsEl.firstChild);
            }
        }

        createResultEl(method) {
            let resultEl = document.createElement('div');
            resultEl.innerText = method.name;
            resultEl.classList.add('searchResultRow');
            resultEl.addEventListener('click', () => {
                this.clearResults();
                this.onSelected(method);
            });
            return resultEl;
        }
    }

    // Top level controller. Currently all DOM input funnels through this class.
    class Controller {

        constructor() {
            let canvas = document.getElementById('canvas');
            let axisCanvas = document.getElementById('axisCanvas');
            let minimapCanvas = document.getElementById('minimapCanvas');
            this.transform = new Transform();
            this.loadingController = new LoadingController();
            this.searchController = new SearchController();
            this.canvasTraceRenderer = new CanvasTraceRenderer(canvas, this.transform);
            this.axisRenderer = new AxisRenderer(axisCanvas, this.transform);
            this.minimapRenderer = new MinimapRenderer(minimapCanvas, this.transform);
            this.detailsController = new DetailsController();

            this.detailsController.onFocus = call => {
                this._focusCall(call);
            };
            this.searchController.onSelected = method => {
                this._selectMethod(method);
            }
        }

        onFileChange(file) {
            this.canvasTraceRenderer.clear();
            let fileReader = new FileReader();
            fileReader.onload = e => {
                let bytes = new Uint8Array(e.target.result);
                let traceDataLoader = new TraceDataProcessor(bytes);
                traceDataLoader.onPop = call => {
                    this.canvasTraceRenderer.addCall(call);
                };
                traceDataLoader.onProgress = this.loadingController.onProgress.bind(this.loadingController);
                traceDataLoader.onDone = (methodRegistry) => {
                    this.searchController.setMethodRegistry(methodRegistry);
                    this.minimapRenderer.setMethodRegistry(methodRegistry);
                    this.canvasTraceRenderer.focusOnRegistry(methodRegistry);
                    this.loadingController.onDone();
                    this._refreshCanvas();
                };
                this.loadingController.onStart(bytes.length);
                traceDataLoader.load();
            };
            fileReader.readAsArrayBuffer(file);
        }

        onKeyPress(keycode) {
            if (document.activeElement === document.getElementById('search')) {
                return false;
            }
            if (this.transform.onKeyPress(keycode)) {
                this._refreshCanvas();
                return true;
            }
            return false
        }

        onMouseWheel(event) {
            this.transform.onMouseWheel(event);
            this._refreshCanvas();
        }

        onCanvasResize(bounds) {
            this.transform.setScreenViewport(bounds);
            this._refreshCanvas();
        }

        onQuery(query) {
            this.searchController.onQuery(query);
        }

        _selectMethod(method) {
            let firstCall = method.getCallAt(0);
            this._focusCall(firstCall);
            this._selectCall(firstCall);
        }

        _focusCall(call) {
            this.canvasTraceRenderer.focus(call);
            this._refreshCanvas();
        }

        _selectCall(call) {
            this.detailsController.selectCall(call);
        }

        _refreshCanvas() {
            this.canvasTraceRenderer.render();
            this.axisRenderer.render();
            this.minimapRenderer.render();
        }
    }

    let controller = new Controller();

    function resizeCanvas() {
        let resize = (canvas) => {
            canvas.width = canvas.getBoundingClientRect().width * PIXEL_RATIO;
            canvas.height = canvas.getBoundingClientRect().height * PIXEL_RATIO;
        };
        let canvas = document.getElementById('canvas');
        resize(canvas);
        resize(document.getElementById('axisCanvas'));
        resize(document.getElementById('minimapCanvas'));
        controller.onCanvasResize(new Rect(0, 0, canvas.width, canvas.height));
    }

    resizeCanvas();

    document.getElementById('file').addEventListener('change', event => {
        let file = event.target.files[0];
        controller.onFileChange(file);
    }, false);

    document.getElementById('canvas').addEventListener('onresize', () => {
        resizeCanvas();
    });

    document.getElementById('canvas').addEventListener('mousewheel', event => {
        event.preventDefault();
        event.stopImmediatePropagation();
        controller.onMouseWheel(event);
    });

    document.getElementById('search').addEventListener('keyup', event => {
        controller.onQuery(event.srcElement.value);
    });

    document.addEventListener('keydown', event => {
        if (document.activeElement === document.getElementById('search')) {
            return false;
        }
        if (controller.onKeyPress(event.keyCode)) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }, false);
</script>

</body>
</html>
